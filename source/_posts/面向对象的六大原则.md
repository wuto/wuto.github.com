---
title: 面向对象的六大原则
date: 2018-11-26 09:07:45
tags:
categories:
---


[TOC]
### 1.单一职责原则
单一职责原则的英文名称是Single Responsibility Principe，缩写是SRP。SRP的定义是：就一个类而言，应该仅有一个引起他变化的原因。简单来说，一个类应该是一组相关性很高的函数、数据的封装。

单一职责所表达出的用意就是“单一”二字。正如上文所说，如何划分一个类、一个函数的职责，每个人都有自己的看法，这需要根据个人经验、具体的业务逻辑而定。但是，他也有一些基本的指导原则，例如，两个完全不一样的功能就不应该放在一个类中。一个类中应该是一组相关性很高的函数、数据的封装。根据具体的业务、功能对类进行相应的拆分，这是优化代码的第一步。
### 2.开闭原则
开闭原则英文全称是Open Close Principle , 缩写是OCP，它是Java世界里最基础的设计原则，它指导我们如何建立一个稳定的，灵活地系统。开闭原则的定义是：软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是，对于修改是封闭的。在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会将错误引入原本已经经过测试的旧代码中，破坏原有系统。因此，当软件需要变化时，我们应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。当然，在现实开发中，只通过继承的方式来升级、维护原有系统只是一个理想化的愿景，因此，在实际的开发过程中，修改原有代码、扩展代码往往是同时存在的。

软件开发过程中，最不会变化的就是变化本身。产品需要不断地升级、维护，没有一个产品从第一版本开发完就再也没有变化了，除非在下个版本诞生之前它已经被终止。而产品需要升级，修改原来的到吗就可能会引发其他的问题。那么，如何确保原有软件模块的正确性，以及尽量少地影响原有模块，答案就是，尽量遵守本章讲述的开闭原则。

开闭原则认为，程序一旦开发完成，程序中一个类的实现只应该因错误而被修改，新的或者改变的特性应该通过新建不同的类实现，新建的类可以通过集成的方式来重用原类的代码。显然开闭原则定义提倡实现继承，已存在的实现类对于修改是封闭的，但是新的实现类可以通过覆写父类的接口应对变化。

可扩展性是框架的最重要特性之一。

软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是对于修改是封闭的，这就是开放--关闭原则。也就是说，当软件需要变化时，我们应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。

开闭原则指导我们，当软件需要变化时，应该尽量通过扩展的方式来实现变化，而不是通过修改已有代码来实现。这里的“应该尽量”4个字说明OCP原则并不是说绝对不可以修改原始类的。当我们嗅到原有的代码“腐化气味”时，应该尽早地重构，以便使代码恢复到正常的“进化”过程，而不是通过继承等方式添加新的实现，这会导致类型的膨胀以及历史遗留代码的冗余。我们的开发过程中也没有那么理想化的状况，完全不用修改原来的代码，因此，在开发过程中需要自己结合具体情况进行考量，是通过修改旧代码还是通过继承使得软件系统更稳定、更领会，在保证去除“代码腐化”的同时，也保证原有模块的正确性。

### 3.里氏替换原则
里氏替换原则英文全称是 Liskov Substitution Principle , 缩写是LSP。LSP的第一种定义是：如果对每一个类型为s的对象O1，都有类型为T的对象O2，使得以T定义的所有程序P在所有的对象O1都代换成O2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。上面这种描述确实不好理解。里氏替换原则第二种定义：所有引用基类的地方必须能透明地使用其子类的对象。

面向对象的语言的三大特点是继承、封装、多态，里氏替换原则就是依赖于继承、多态这两大特性。里氏替换原则简单来说就是，所有引用基类的地方必须能透明地使用其子类的对象。通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是反过来就不行了，有子类出现的地方，父类未必就能适应。（抽象）

里氏替换原则的核心原理是抽象，抽象又依赖于继承这个特性，在OOP当中，继承的优缺点都相当明显。优点有以下几点：

（1）代码重用，减少创建类的成本，每个子类都拥有父类的方法和属性；

（2）子类与父类基本相似，但又与父类有所区别；

（3）提高代码的可扩展性。

继承的缺点：

（1）继承是侵入性的，只要继承就必须拥有父类的所有属性和方法；

（2）可能造成子类代码冗余、灵活性降低，因为子类必须用户父类的属性和方法。

事物总是具有两面性的，如何权衡利弊都是需要根据具体情况来做出选择并加以处理。里氏替换原则指导我们构建扩展性更好的软件系统。

建立抽象，通过抽象建立规范，具体的实现在运行时替换掉抽象，保证系统的可扩展性、灵活性。开闭原则和里氏替换原则往往是生死相依、不离不弃的，通过里氏替换来达到对扩展开放，对修改关闭的效果。然而，这两个原则都同时强调了一个OOP的重要特性---抽象，因此，在开发过程中运用抽象是走向代码优化的重要一步。

### 4.依赖倒置原则

依赖倒置原则英文全称是Dependence Inversion Principle，缩写是DIP。依赖倒置原则指代了一种特定的解耦形式，使得高层次的模块不依赖与低层次的模块的实现细节的目的，依赖模块被颠倒了。

依赖倒置原则有以下几个关键字：

（1）高层模块不应该依赖低层模块，两者都应该依赖其抽象；

（2）抽象不应该依赖细节；

（3）细节应该依赖抽象。

在Java语言中，抽象就是指接口或抽象类，两者都是不能直接被实例化的；细节就是实现类，实现接口或继承抽象类而产生的类就是细节，其特点就是，可以直接被实例化，也就是可以加上一个关键字new 产生一个对象。高层模块就是调用端，低层模块就是具体实现类。依赖倒置原则在Java语言中的表现就是：**模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的**。这又是一个将理论抽象化的实例，其实一句话就可以概括：面向接口编程，或者说是面向抽象编程，这里的抽象指的是接口或者抽象类。面向接口编程是面向对象精髓之一，也就是上面两节强调的抽象。

如果类与类直接依赖于细节，那么他们之间就有直接的耦合，当具体实现需要变化时，意味着要同时修改依赖者的代码，这限制了系统的可扩展性。

### 5.接口隔离原则

接口隔离原则英文全称是InterfaceSegregation Principe，缩写是ISP。ISP的定义是：客户端不应该依赖它不需要的接口。另一种定义是：类间的依赖关系应该建立在最小的接口上。接口隔离原则将非常庞大、臃肿的接口拆分成更小的和更具体的接口，这样客户将会只需要知道他们感兴趣的方法。接口隔离原则的目的是系统解开耦合，从而容易重构、更改和重新部署。

接口隔离原则说白了就是，让客户端依赖的接口尽可能地小。

单一职责、开闭原则、里氏替换、接口隔离以及依赖倒置（也称依赖反转）5个原则定义为SOLID原则，作为面向对象编程的5个基本原则。当这些原则被遗弃应用时，它们使得一个软件系统更清晰、简单，最大程度地拥抱变化。SOLID被典型地应用在测试驱动开发上，并且是敏捷开发以及自适应软件开发基本原则的重要组成部分。这几大原则最终可以化为这几个关键词：抽象、单一职责、最小化。那么，在实际开发过程中如何权哥、实践这些原则，需要不断去思考与领悟。

### 6.迪米特原则

迪米特原则应为全称为Law of Demeter，缩写是LOD，也称为最少知识原则（Least KnowLedge Principe）。虽然名字不同，但描述的是同一个原则：一个对象应该对其他对象有最少的了解。通俗地将，一个类应该对自己需要耦合或调用的类知道得最少。类的内部如何实现与调用者或者依赖者没关系，调用者或者依赖者只需要知道它需要的方法即可，其他的可一概不用管。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对一个类的影响也越大。

迪米特法则还有一个英文解释是Only talk to your immedate friends ，翻译过来就是：只与直接的朋友通信。什么叫做直接的朋友呢？每个对象都必然会与其他对象有耦合关系，两个对象之间的耦合就称为朋友关系，这种关系的类型有很多，如组合、聚合、依赖等。